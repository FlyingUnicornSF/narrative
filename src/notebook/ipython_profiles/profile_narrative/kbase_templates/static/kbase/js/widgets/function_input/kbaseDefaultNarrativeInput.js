/**
 * @author Bill Riehl <wjriehl@lbl.gov>
 * @public
 */

(function( $, undefined ) {
    $.KBWidget({
        name: "kbaseDefaultNarrativeInput",
        parent: "kbaseNarrativeInput",
        version: "1.0.0",
        options: {
            loadingImage: "../images/ajax-loader.gif",
        },

        init: function(options) {
            this._super(options);

            this.render();
            return this;
        },

        /**
         * Builds the input div for a function cell, based on the given method object.
         * @param {Object} method - the method being constructed around.
         * @returns {String} an HTML string describing the available parameters for the cell.
         * @private
         */
        render: function() {

            // figure out all types from the method
            var method = this.options.method;
            
            var params = method.properties.parameters;
            var lookupTypes = [];
            for (var p in params) {
                lookupTypes.push(params[p].type);
            }
            this.trigger('dataLoadedQuery.Narrative', [lookupTypes, $.proxy(
                function(objects) {
                    var inputDiv = "<div class='kb-cell-params'><table class='table'>";
                    var params = method.properties.parameters;
                    for (var i=0; i<Object.keys(params).length; i++) {
                        var pid = 'param' + i;
                        var p = params[pid];

                        var input = "";
                        # XXX: HACK to disable the pull-down
                        if (objects[p.type] && objects[p.type].length > 5000) {
                            var objList = objects[p.type];
                            objList.sort(function(a, b) {
                                if (a[0] < b[0])
                                    return -1;
                                if (a[0] > b[0])
                                    return 1;
                                return 0;
                            });

                            input = "<select name='" + pid + "' > ";
                            for (var j=0; j<objects[p.type].length; j++) {
                                input += "<option value='" + objList[j][0] + "'>" + objList[j][0] + "</option>";
                            }
                            input += "</select>";
                        }

                        else {
                            input = "<input name='" + pid + "' value='' type='text'></input>";
                        }
                        inputDiv += "<tr style='border:none'>" + 
                                        "<td style='border:none'>" + p.ui_name + "</td>" + 
                                        "<td style='border:none'>" + input + "</td>" +
                                        "<td style='border:none'>" + p.description + "</td>" +
                                    "</tr>";
                    }
                    inputDiv += "</table></div>";
                    this.$elem.append(inputDiv);
                },
                this
            )]);
        },

        /**
         * Returns a list of parameters in the order in which the given method
         * requires them.
         * @return {Array} an array of strings - one for each parameter
         * @public
         */
        getParameters: function() {
            var paramList = [];

            $(this.$elem).find("[name^=param]").filter(":input").each(function(key, field) {
                paramList.push(field.value);
            });

            return paramList;
        },

        /**
         * Returns an object representing the state of this widget.
         * In this particular case, it is a list of key-value pairs, like this:
         * { 
         *   'param0' : 'parameter value',
         *   'param1' : 'parameter value'
         * }
         * with one key/value for each parameter in the defined method.
         */
        getState: function() {
            var state = {};

            $(this.$elem).find("[name^=param]").filter(":input").each(function(key, field) {
                state[field.name] = field.value;
            });

            return state;
        },

        /**
         * Adjusts the current set of parameters based on the given state.
         * Doesn't really do a whole lot of type checking yet, but it's assumed that
         * a state will be loaded from an object generated by getState.
         */
        loadState: function(state) {
            if (!state)
                return;

            $(this.$elem).find("[name^=param]").filter(":input").each(function(key, field) {
                var $field = $(field);
                var fieldName = $field.attr("name");

                // If it's a text field, just dump the value in there.
                if ($field.is("input") && $field.attr("type") === "text") {
                    $field.val(state[fieldName]);
                }

                // If it's a select field, do the same... we'll have comboboxen or something,
                // eventually, so I'm just leaving this open for that.
                else if ($field.is("select")) {
                    $field.val(state[fieldName]);
                }
            });
        },
    });
})( jQuery );