#!/usr/bin/env python
"""
Dump log info from MongoDB
"""
import argparse
import csv
import logging
import os
import sqlite3
import sys
import time
#
import pymongo
import yaml

logging.basicConfig()
_log = logging.getLogger("kb-log-dump")

def error(msg):
    _log.error(msg)

def connect_mongo(conf):
    try:
        info = yaml.load(open(conf))
        for key in 'db_host', 'db_port', 'db', 'user', 'password':
            if not key in info:
                error(
                    "Configuration file is missing value for '{}'".format(key))
                return -1
    except IOError as err:
        error("Cannot open configuration file '{}': {}".format(conf, err))
        return -1
    except yaml.error.YAMLError as err:
        error("Cannot parse configuration file as YAML")
        return -1

    try:
        db = pymongo.MongoClient(info["db_host"], info["db_port"])[info["db"]]
    except pymongo.errors.PyMongoError as err:
        error("Cannot connect to MongoDB '{}' at {}:{}".format(
            info["db"], info["db_host"], info["db_port"]))
        return -1
    if not db.authenticate(info["user"], info["password"]):
        error("Could not authenticate to MongoDB '{}' at {}:{}".format(
            info["db"], info["db_host"], info["db_port"]))
    c = db[info["collection"]]
    return c

class DB(object):
    DUPLICATES_MAX = 10

    def __init__(self, fname, table_name):
        # sync this with 'fields' in main()
        self._columns = ['date', 'ts', 'event', 'narr', 'user', 'name',
                         'dur', 'session_id']
        self._table = table_name    
        self._is_mem = fname == ':memory:'
        try:
            sq = sqlite3.connect(fname)
        except sqlite3.OperationalError:
            raise ValueError("Bad DB filename '{}'".format(fname))
        sq.execute(self._create_table_stmt())
        self._sq = sq
        self._insert_stmt = 'INSERT INTO {table_name} ({columns}) ' \
                            'VALUES ({{values}})'.format(
            table_name=self._table, columns=','.join(self._columns))
        self._rkeys, self._duplicates, self._disable_insert = set(), 0, False

    def _create_table_stmt(self):
        stmt = "CREATE TABLE IF NOT EXISTS {table_name} ({columns})"
        if self._is_mem:
            constraints = []
        else:
            constraints = ['CONSTRAINT c1 UNIQUE (ts, session_id)']
        return stmt.format(table_name=self._table,
                           columns=','.join(self._columns + constraints))

    def add(self, rec):
        """Add record to sqlite3 db.
        """
        if self._disable_insert:
            return
        if self._is_mem:
            key = '#'.join([rec['ts'], rec['session_id']])
            if key in self._rkeys:
                self._add_duplicate()
            self._rkeys.add(key)
        cursor = self._sq.cursor()
        values = [rec[c] for c in self._columns]
        ivalues = []
        for v in values:
            if isinstance(v, float):
                ivalues.append('{:f}'.format(v))
            else:
                ivalues.append('"' + v + '"')
        stmt = self._insert_stmt.format(values=','.join(ivalues))
        # add record
        try:
            cursor.execute(stmt)
        except sqlite3.IntegrityError:
            self._add_duplicate()
        cursor.close()

    def _add_duplicate(self):
        self._duplicates += 1
        if self._duplicates > self.DUPLICATES_MAX:
            _log.error("Duplicate record limit ({:d}) reached."
                       " All further inserts will be ignored."
                       .format(self.DUPLICATES_MAX))
            self._disable_insert = True

    def query(self, q):
        cursor = self._sq.cursor()
        result = cursor.execute(q)
        return result

    def close(self):
        self._sq.commit()
        self._sq.close()

def main(args):
    c = connect_mongo(args.conf)
    sq = DB(args.sq_file, args.sq_table)

    spec = {'created': {'$gte': args.daterange[0],
                        '$lte': args.daterange[1]}}
    # when updating this value, also update DB._create_stmt()
    fields = ('event', 'created', 'narr', 'user', 'name', 'dur', 'session_id')
    recs, first = c.find(spec=spec, fields=fields), True
    for rec in recs:
        e = rec['event']
        if e not in ('open', 'func.end'):
            continue
        first = False
        ts = rec['created']
        localdate = time.strftime('%Y-%m-%d', time.localtime(ts))
        rec.update({'date': localdate, 'ts': '{:f}'.format(ts)})
        if e == 'open':
            rec.update({'dur': 0., 'event': 'O'})
        else:
            rec['event'] = 'F'
        sq.add(rec)
    if first:
        print("No records found")
    else:
        if len(args.groups) > 0:
            group_expr = ','.join(args.groups)
            stmt = 'SELECT {g},SUM(dur) FROM {t} GROUP BY {g}'.format(
                t=args.sq_table, g=group_expr)
            print(stmt)
            rows = sq.query(stmt)
            writer = csv.writer(sys.stdout)
            writer.writerow(list(args.groups) + ['total_sec'])
            for row in rows:
                writer.writerow(row)
        sq.close()
    return 0

# argument types

def csv_list(s):
    return s.split(',')

def date_range(s):
    """Parse a string with a date range and return a tuple of
    floating-point seconds since the epoch.

    :raises: ValueError, for bad input formats
    """
    dates = s.split(':')
    if len(dates) != 2:
        raise ValueError("Date range not in format '<date1>:<date2>'")
    result = []
    for date in dates:
        try:
            epoch_sec = time.mktime(time.strptime(date, '%Y-%m-%d'))
        except ValueError:
            raise ValueError("Date '{}' not in format 'YYYY-MM-DD'".format(date))
        result.append(epoch_sec)
    return tuple(result)

# main

def parse_args():
    conf = os.environ.get("KBASE_PROXY_CONFIG", "narrative-log-proxy.conf")
    p = argparse.ArgumentParser(description=__doc__.strip())
    p.add_argument("-g", "--group", dest='groups', type=csv_list, default=[],
                   help='Group by these comma-separated fields')
    p.add_argument("-c", "--conf", dest='conf', default=conf,
                   help="Configuration file (default=%(default)s)")
    p.add_argument("-d", "--dates", dest='daterange', type=date_range,
                   default='1970-01-01:2099-12-31',
                   help="Date range, in format YYYY-MM-DD:YYYY-MM-DD"
                        " (default=%(default)s). Uses local timezones")
    p.add_argument("-f", "--sqlite-file", dest='sq_file',
                   default="logs.db", help="sqlite3 file (default=%(default)s)")
    p.add_argument("-t", "--sqlite-table", dest='sq_table', default="narrative",
                   help="sqlite3 table (default=%(default)s")
    args = p.parse_args()
    return args

if __name__ == '__main__':
    sys.exit(main(parse_args()))
